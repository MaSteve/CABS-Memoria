\chapter{Sintaxis y semántica}
\section{Sintaxis de CABS}
La mayoría de lenguajes de programación del mercado siguen una sintaxis común similiar a la que tiene el lenguaje original en el que se suelen basar que es C. A la hora de definir la sintaxis de CABS tomaremos como referencia de nuevo la de ese lenguaje.\\

Para sentar las bases de la notación que se usará de ahora en adelante para definir la semántica de nuestro lenguaje, diremos que $\P$ es un programa en CABS formado por instrucciones globales como lo son las declaraciones de variables globales y las declaraciones de funciones.\\

La declaración de variables constarán de un tipo y de un nombre de variable seguido de un punto y coma. Las funciones estarán formadas por un tipo de rotorno, un nombre de función, una lista de argumentos (es posible que sea vacia), un cuerpo con instrucciónes $S \in \Stm$ y una expresión de retorno. A modo de ilustración podemos ver el siguiente código

\lstinputlisting{code.0.1.txt}

donde se muestra la declaración de dos variables globales y de una función.\\

Los tipos que manejaremos en nuestro lenguaje serán enteros y booleanos, cuyos identificadores serán \emph{int} y \emph{bool} respectivamente. Permitiremos además la declaración y el uso de arrays de enteros y booleanos en asignaciones y expresiones aritmético-lógicas y como argumentos de funciones. No se podrán usar como tipo de retorno. Un ejemplo del uso de arrays es el siguiente:

\lstinputlisting{code.0.2.txt}

Las instrucciones $S$ del cuerpo de una función de un programa son las típicas de un lenguaje imperativo, entre las que se encuentran las asignaciones, las operaciones aritmetico lógicas, las instrucciones de control, como los condicionales y los bucles y, la clave de un lenguaje con concurrencia, un $\thread$ para la ejecución de funciones en paralelo imitando el comportamiento de la librería pthread en C. Veamos un ejemplo que use esta última construcción:

\lstinputlisting{code.0.3.txt}
Como podemos ver, las llamadas concurrentes son similares a las llamadas a procedimientos habituales precedidas por la palabra reservada $\thread$.

\section{Semántica de CABS}
A continuación pasamos a hablar de la semántica del lenguaje CABS. La idea es dar un significado al código CABS de modo que quede definido el comportamiento de cada una de las construcciones presentes en el lenguaje. Para este propósito escogeremos una semántica de paso corto en la que la derivación se puede interpretar como una secuencia de pasos que simulan las transiciones que generaría un código ejecutado en un ordenador real, es decir, los cambios en memoria y en la instrucción actual marcada por un contador de programa.\\

En una primera sección daremos las definiciones básicas de lo que serán los estados de nuestro programa para, posteriormente, especificar cuales serán las reglas que marcaran las transiciones entre ellos. Por último, mostraremos algunos ejemplos de derivación a partir de unos programas básicos.

\subsection{Preámbulo semántico}
Los programas en CABS se pueden entender, de forma simplificada, como unas secuencias de pasos que van a menejar unos valores enteros y lógicos posiblemente almacenados en una memoria donde también se guardarán los resultados desprendidos de las operaciones que se realicen. Es por esto que en primer lugar tenemos que definir un conjunto de valores $\V = \Z \cup \B$ que sea la unión de los enteros y de los booleanos, los elementos básicos de todo programa.\\

Una primera parte de la representación del estado estará formada por las variables globales de nuestro programa. Definimos $\Gs = \Var \hookrightarrow \V$ el conjunto de funciones parciales del conjunto de variables al conjunto de valores. El estado actual de nuestras variables globales será una función de este conjunto y por lo general nos referiremos a ella con la letra $\G$. Posteriormente cuando hablemos de variables locales también las definiremos como un conjunto de funciones similares pero que trataremos por separado por comodidad. El conjunto $\Var$ contiene todos los nombre de variable posibles y usaremos $\G\,var$ para referirnos al valor almacenado por la variable global $var$. Por ser una función parcial quedan reflejadas en $\G$ únicamente las variables que han sido previamente declaradas.\\

Por otro lado nos encontramos en nuestro lenguaje con la necesidad de definir un conjunto que recoja la información básica de las funciones y procedimientos. Definimos $\Fs = \Func \hookrightarrow (\T \times \Stm \times \Args \times (\Exp \cup \{\varepsilon\}))$ el conjunto de funciones parciales que asocia un nombre de función a su definición. Una función quedará definida por su tipo de retorno $t \in \T$, su código $S \in \Stm$, sus argumentos de entrada $\args \in \Args$ y su expresión de retorno $e \in \Exp \cup \{\varepsilon\}$. Según las necesidades, la expresión de retorno será una expresión booleana, una expresión aritmética o simplemente será la expresión vacia, empleada para los procedimientos. De nuevo tenemos un conjunto de nombres de funciones $\Func$. En principio los nombres de variable y de función son los mismos en los lenguajes de programación habituales y es también el caso de CABS, no obstante, por simplicidad, consideraremos en la semántica que son conjuntos separados. A su vez, contamos también con la ventaja de las funciones parciales en $\Fs$ que solo tendrán la información de aquellas funciones que en verdad hayan sido definidas en el programa. $\F$ será la metavariable que usaremos para referirnos a una función de $\Fs$ concreta.\\

Para dar un significado a nuestro programas tenemos que definir qué va a representar para nosotros su estado de ejecución. Definimos el conjunto de estados $\State = \Gs \times \Fs \times \RPs$ como una tupla que recoja la información de las variables globales y de las funciones definidas en nuestro programa $\P$, así como, una lista de marcos de ejecución o runtime processes que contendrá la información local de los procesos. Esto último quedará recogido en los elementos de $\RPs = $. Usaremos la metavariable $\RP$ para referirnos a una lista de marcos de ejecución concreta.\\

La idea a seguir para definir nuestra semántica será apoyarnos en dos funciones auxiliares $\init$ y $\start$ que respectivamente inicializarán el estado global del programa y lanzarán a ejecución la función inicial $\main$. Pasemos pues a definir la primera de ellas.

\subsubsection{La función $\init$.}
Definimos la función $\init: \Prog \hookrightarrow \State$ de forma recursiva del siguiente modo.
\begin{align*}
  \init(\varepsilon) &= (\nil, \nil, [])\\
  \init(int \var \; \P) &= (\G\ass{\var}{0}, \F, \RP) \text{ donde } \init(\P) = (\G, \F, \RP)\\
  \init(bool \var \; \P) &= (\G\ass{\var}{\False}, \F, \RP) \text{ donde } \init(\P) = (\G, \F, \RP)\\
  \init(int \, \func(\args) \{ S\; \return a\} \P) &= (\G, \F\ass{\func}{(int, S, \args, a)}, \RP) \\ &\text{ donde } \init(\P) = (\G, \F, \RP)\\
  \init(bool \, \func(\args) \{ S\; \return b\} \P) &= (\G, \F\ass{\func}{(bool, S, \args, b)}, \RP) \\ &\text{ donde } \init(\P) = (\G, \F, \RP)\\
  \init(void \, \func(\args) \{ S\} \P) &= (\G, \F\ass{\func}{(void, S, \args, \varepsilon)}, \RP) \\ &\text{ donde } \init(\P) = (\G, \F, \RP)\\
\end{align*}
\subsubsection{La función (regla) $\start$.}
Definimos la función $\start: \State \hookrightarrow \State$ como
$$
\start((\G, \F, \RP)) = (\G, \F, [(\nil:[], S)]) \text{ donde } \F(main) = (int, S, \args, 0)
$$

Con esto conseguimos crear un nuevo marco de ejecución con el código inicial de main. Nótese que la función inicializa la pila de ambitos de variables locales con el ambito $\nil$ que no contiene ninguna variable inicializada.

\subsubsection{Semántica (Expresiones aritmético-lógicas).}
(Primero hablemos de las funciones aritméticas que ya son un jaleo. Se trata de expresiones con operandos, numerales y variables junto con llamadas funciones (por el momento como si no tuvieran argumentos!!!)).\\

Tenemos que definir una función (parcial) que dada una expresión (aritmética reducida) nos devuelva otra expresión más simplificada, pudiendo emplear un estado para ello (permitiendo modificaciones del mismo), hasta eventualmente quedarnos con un valor (entero por el momento).\\

De ahora en adelante nos referimos por el conjunto $\AExp$ a la unión de expresiones aritméticas y valores enteros.\\

Buscamos definir la función semántica $\A: (\AExp \times \State) \hookrightarrow (\AExp \times \State)$ mediante las siguientes reglas:

\begin{prooftree*}
    \Infer[left label=$\numa$]0{\st{n}{(\G, \F, \RP \leadsto (s, S))} \staexp \st{\N \eval{n}}{(\G, \F, \RP \leadsto (s, S))}}
\end{prooftree*}

\begin{prooftree*}
        \hypo{local(x) = v}
        \hypo{G(x) = \Undef}
    \Infer[left label=$\varal$]2{\st{x}{(\G, \F, \RP \leadsto (local:s, S))} \staexp \st{v}{(\G, \F, \RP \leadsto (local:s, S))}}
\end{prooftree*}

\begin{prooftree*}
        \hypo{G(x) = v}
        \hypo{local(x) = undef}
    \Infer[left label=$\varag$]2{\st{x}{(\G, \F, \RP \leadsto (local:s, S))} \staexp \st{v}{(\G, \F, \RP \leadsto (local:s, S))}}
\end{prooftree*}

\begin{prooftree*}
        \hypo{\st{a_1}{(\G, \F, \RP \leadsto (s, S))} \staexp \st{a_1'}{(\G, \F, \RP \leadsto (s', S'))}}
    \Infer[left label=$\opaa$]1{\st{a_1 \bigodot a_2}{(\G, \F, \RP \leadsto (s, S))} \staexp \st{a_1' \bigodot a_2}{(\G, \F, \RP \leadsto (s', S'))}}
\end{prooftree*}

\begin{prooftree*}
        \hypo{\st{a_2}{(\G, \F, \RP \leadsto (s, S)))} \staexp \st{a_2'}{(\G, \F, \RP \leadsto (s', S')))}}
    \Infer[left label=$\opab$]1{\st{v \bigodot a_2}{(\G, \F, \RP \leadsto (s, S)))} \staexp \st{v \bigodot a_2'}{(\G, \F, \RP \leadsto (s', S')))}}
\end{prooftree*}

\begin{prooftree*}
    \Infer[left label=$\opac$]0{\st{v_1 \bigodot v_2}{(\G, \F, \RP \leadsto (s, S))} \staexp \st{v_1 \bigodot_{\N} v_2}{(\G, \F, \RP \leadsto (s, S))}}
\end{prooftree*}

\begin{prooftree*}
        \hypo{\st{a}{(\G, \F, \RP \leadsto (s, S))} \staexp \st{a'}{(\G, \F, \RP \leadsto (s', S'))}}
    \Infer[left label=$\unaa$]1{\st{\Unstack{a}}{(\G, \F, \RP \leadsto (s, S))} \staexp \st{\Unstack{a'}}{(\G, \F, \RP \leadsto (s', S'))}}
\end{prooftree*}

\begin{prooftree*}
    \Infer[left label=$\unab$]0{\st{\Unstack{v}}{(\G, \F, \RP \leadsto (local:s, S))} \staexp \st{v}{(\G, \F, \RP \leadsto (s, S))}}
\end{prooftree*}

\begin{prooftree*}
        \hypo{\F(\func) = (int, S_F, [], a)}
    \Infer[left label=$\calla$]1{\st{\func()}{(\G, \F, \RP \leadsto (local:s, S))} \staexp \st{\Unstack{a}}{(\G, \F, \RP \leadsto (\nil:local:s, S_F\;S))}}
\end{prooftree*}

\subsubsection{Semántica (Instrucciones). (Hay que meter más tipos, limitar declaraciones y un largo etc)}
\begin{prooftree*}
    \Infer[left label=$\declic$]0{(\G, \F, \RP \leadsto (local:s, int \var;S)) \stns (\G, \F, \RP \leadsto (local\ass{\var}{0}:s, S))}
\end{prooftree*}

\begin{prooftree*}
    \Infer[left label=$\declbc$]0{(\G, \F, \RP \leadsto (local:s, bool \var;S)) \stns (\G, \F, \RP \leadsto (local\ass{\var}{\False}:s, S))}
\end{prooftree*}

\begin{prooftree*}
        \hypo{\st{a}{(\G, \F, \RP \leadsto (local:s, \varepsilon))} \staexp \st{a'}{(\G, \F, \RP \leadsto (s', S_{\A}))}}
    \Infer[left label=$\assac$]1{(\G, \F, \RP \leadsto (local:s,\var = a\;S)) \stns (\G, \F, \RP \leadsto (s', S_{\A}\;\var = a'\;S))}
\end{prooftree*}

\begin{prooftree*}
        \hypo{is\_local(var)}
    \Infer[left label=$\assvc$]1{(\G, \F, \RP \leadsto (local:s,\var = v\;S)) \stns (\G, \F, \RP \leadsto (local\ass{\var}{v}:s, S))}
\end{prooftree*}

\begin{prooftree*}
        \hypo{is\_global(var)}
    \Infer[left label=$\assvcg$]1{(\G, \F, \RP \leadsto (local:s,\var = v\;S)) \stns (\G\ass{\var}{v}, \F, \RP \leadsto (local:s, S))}
\end{prooftree*}

%%%%%%%%%
\iffalse
\begin{prooftree*}
        \hypo{(\G, \F, \RP \leadsto (local:s, S_1)) \stns (\G, \F, \RP \leadsto (s', S_1'))}
    \Infer[left label=$\compac$]1{(\G, \F, \RP \leadsto (local:s, S_1\;S_2)) \stns (\G, \F, \RP \leadsto (s', S_1'\;S_2))}
\end{prooftree*}


\begin{prooftree*}
        \hypo{(\G, \F, \RP \leadsto (local:s, S_1)) \stns (\G, \F, \RP \leadsto (s', S_1'))}
    \Infer[left label=$\compac$]1{(\G, \F, \RP \leadsto (local:s, S_1\;S_2)) \stns (\G, \F, \RP \leadsto (s', S_1'\;S_2))}
\end{prooftree*}
\fi
%%%%%%%%%

\begin{prooftree*}
        \hypo{\st{b}{(\G, \F, \RP \leadsto (local:s, \varepsilon))} \stbexp \st{b'}{(\G, \F, \RP \leadsto (s', S_{\B}))}}
    \Infer[left label=$\ifac$]1{(\G, \F, \RP \leadsto (local:s, \If{b}{S_1}{S_2}S)) \stns (\G, \F, \RP \leadsto (s', S_{\B}\;\If{b'}{S_1}{S_2}S))}
\end{prooftree*}

\begin{prooftree*}
    \Infer[left label=$\iftc$]0{(\G, \F, \RP \leadsto (local:s, \If{\True}{S_1}{S_2}S)) \stns (\G, \F, \RP \leadsto (local:s, S_1\;S))}
\end{prooftree*}

\begin{prooftree*}
    \Infer[left label=$\iffc$]0{(\G, \F, \RP \leadsto (local:s, \If{\False}{S_1}{S_2}S)) \stns (\G, \F, \RP \leadsto (local:s, S_2\;S))}
\end{prooftree*}

\begin{prooftree*}
        \Infer[left label=$\wac$]0{(\G, \F, \RP \leadsto (local:s, \while{b}{S_1}S)) \stns (\G, \F, \RP \leadsto (local:s, \Ifp{b}{S_1\;\while{b}{S_1}}S))}
\end{prooftree*}



%%%%%%%
\iffalse
\begin{prooftree*}
    \Infer[left label=$\wtc$]0{(\G, \F, \RP \leadsto (local:s, \while{\True}{S_1}S)) \stns (\G, \F, \RP \leadsto (local:s, S_1\while{AHGGGG}{S_1}\;S))}
\end{prooftree*}

\begin{prooftree*}
    \Infer[left label=$\wfc$]0{(\G, \F, \RP \leadsto (local:s, \while{\False}{S_1}S)) \stns (\G, \F, \RP \leadsto (local:s, S))}
\end{prooftree*}
\fi
%%%%%%

\begin{prooftree*}
    \Infer[left label=$\enac$]0{(\G, \F, \RP \leadsto (s, \varepsilon))) \stns (\G, \F, \RP))}
\end{prooftree*}

\begin{prooftree*}
        \hypo{\F(\func) = (t, S_F, [], e)}
    \Infer[left label=$\threadc$]1{(\G, \F, \RP \leadsto (s, \thread \,\func()\;S)) \stns (\G, \F, (\RP \cup (\nil:[], S_F)) \leadsto (s, S))}
\end{prooftree*}
